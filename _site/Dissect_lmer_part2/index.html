<!DOCTYPE html>
<html>
  <head>
    <title>Dissecting lme4's lmer function. Part 2. â€“ Alexej Gossmann â€“ New Orleans ðŸ˜Ž</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="Last time I started to analyze the function lmer that is used to fit linear mixed models in the R package lme4. I have delineated the general steps taken by lmer, and looked at the employed formula module in more detail. The formula module evaluates the provided R model formula to model matrices, vectors and parameters. The next step is to use these to define the objective function that needs to be minimized, which is the profiled deviance or the profiled REML criterion in this case. The objective function is returned by the function mkLmerDevfun which is dissected in what follows.

" />
    <meta property="og:description" content="Last time I started to analyze the function lmer that is used to fit linear mixed models in the R package lme4. I have delineated the general steps taken by lmer, and looked at the employed formula module in more detail. The formula module evaluates the provided R model formula to model matrices, vectors and parameters. The next step is to use these to define the objective function that needs to be minimized, which is the profiled deviance or the profiled REML criterion in this case. The objective function is returned by the function mkLmerDevfun which is dissected in what follows.

" />
    
    <meta name="author" content="Alexej Gossmann" />

    
    <meta property="og:title" content="Dissecting lme4's lmer function. Part 2." />
    <meta property="twitter:title" content="Dissecting lme4's lmer function. Part 2." />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Alexej Gossmann - New Orleans ðŸ˜Ž" href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
 
    <!-- MathJax interation-->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [["$","$"]]}});
      MathJax.Hub.Config({TeX: {Macros:{subscript:['_{#1}',1],superscript:['^{#1}',1]}}});
    </script> 
    <!-- Turn on equation numbering -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
    </script>
    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full">
    </script>
 </head>

  <body>
    <div class="wrapper-masthead">
      <header class="masthead clearfix">
        <a href="/" class="site-avatar"><img src="https://avatars0.githubusercontent.com/u/11449372?v=3&s=460" /></a>

        <div class="site-info">
          <h1 class="site-name"><a href="/">Alexej Gossmann</a></h1>
          <p class="site-description">New Orleans ðŸ˜Ž</p>
        </div>

        <nav>
          <a href="/about" class="blue">About</a>
          <a href="/" class="yellow">Blog</a>
          <a href="/talks" class="green">Presentations</a>
          <a href="/publications" class="magenta">Publications</a>
          <a href="/software" class="cyan">Software</a>
        </nav>
      </header>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Dissecting lme4's lmer function. Part 2.</h1>

  <div class="entry">
    <p><a href="http://agisga.github.io/Dissect_lmer_part1/">Last time</a> I started to analyze the function <code class="highlighter-rouge">lmer</code> that is used to fit linear mixed models in the R package <code class="highlighter-rouge">lme4</code>. I have delineated the general steps taken by <code class="highlighter-rouge">lmer</code>, and looked at the employed formula module in more detail. The formula module evaluates the provided R model formula to model matrices, vectors and parameters. The next step is to use these to define the objective function that needs to be minimized, which is the profiled deviance or the profiled REML criterion in this case. The objective function is returned by the function <code class="highlighter-rouge">mkLmerDevfun</code> which is dissected in what follows.</p>

<h1 id="set-up-the-deviance-function---mklmerdevfun">Set up the deviance function - <code class="highlighter-rouge">mkLmerDevfun</code></h1>

<p>Much of the code of <code class="highlighter-rouge">mkLmerDevfun</code> and the functions called from therein deals with the situation when the user wants to fit a <em>generalized</em> or <em>nonlinear</em> mixed model, but calls <code class="highlighter-rouge">lmer</code> instead of other respectively designated functions. Then the code repackages the provided function arguments and passes them to the respective function (which should have been called by the user in the first place). I will disregard such passages of the code, because Iâ€™m only interested in the <em>linear</em> mixed model capabilities right now (besides, I find that it would have been a better design to simply abort the function execution with a warning in such cases).</p>

<p>Okay, now letâ€™s dislimb, dismember and dissect!</p>

<p>The function <code class="highlighter-rouge">mkLmerDevfun</code> is defined in the file <code class="highlighter-rouge">modular.R</code> as:</p>

<div class="language-R highlighter-rouge"><pre class="highlight"><code><span class="n">mkLmerDevfun</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">reTrms</span><span class="p">,</span><span class="w"> </span><span class="n">REML</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">verbose</span><span class="o">=</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">control</span><span class="o">=</span><span class="n">lmerControl</span><span class="p">(),</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w">
</span></code></pre>
</div>

<p>It begins by extracting some variables from the function call, most importantly:</p>

<ul>
  <li><code class="highlighter-rouge">rho</code> - a new environment with the parent being the environment from which <code class="highlighter-rouge">mkLmerDevfun</code> was called (containing who knows whatâ€¦),</li>
  <li><code class="highlighter-rouge">rho$pp</code> - a new <code class="highlighter-rouge">merPredD</code> object, which stores the dense model matrix <code class="highlighter-rouge">X</code>, the transpose of the sparse model matrix for the random effects <code class="highlighter-rouge">Zt</code>, <code class="highlighter-rouge">Lambdat</code>the transpose of the sparse lower triangular relative variance, <code class="highlighter-rouge">Lind</code> integer vector of the same length as the <code class="highlighter-rouge">x</code> slot in the <code class="highlighter-rouge">Lambdat</code> field (I donâ€™t know yet what itâ€™s for), <code class="highlighter-rouge">theta</code> numeric vector of variance component parameters, <code class="highlighter-rouge">n</code> sample size, and other auxiliary parameters computed from these.</li>
  <li><code class="highlighter-rouge">rho$resp</code> - an <code class="highlighter-rouge">lmerResp</code> object, which essentially holds the response vector $y$, and additionally some associated parameters (like the weights for each observation, offset terms and others), as well as the REML flag.</li>
</ul>

<p>Then <code class="highlighter-rouge">mkLmerDevfun</code> diverts to the function <code class="highlighter-rouge">mkdevfun</code> (defined in <code class="highlighter-rouge">lmer.R</code>), which takes as input the environment <code class="highlighter-rouge">rho</code> and returns a function <code class="highlighter-rouge">devfun</code> with <code class="highlighter-rouge">rho</code> as an associated environment. The function <code class="highlighter-rouge">mkdevfun</code> sets</p>

<div class="language-R highlighter-rouge"><pre class="highlight"><code><span class="n">rho</span><span class="o">$</span><span class="n">lmer_Deviance</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">lmer_Deviance</span><span class="w">
</span></code></pre>
</div>

<p>and defines <code class="highlighter-rouge">devfun</code> as</p>

<div class="language-R highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w"> </span><span class="n">.Call</span><span class="p">(</span><span class="n">lmer_Deviance</span><span class="p">,</span><span class="w"> </span><span class="n">pp</span><span class="o">$</span><span class="n">ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">resp</span><span class="o">$</span><span class="n">ptr</span><span class="p">(),</span><span class="w"> </span><span class="nf">as.double</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="w">
</span></code></pre>
</div>

<p>I inspect the C++ function <code class="highlighter-rouge">lmer_Deviance</code> in great detail below.</p>

<p>If all random effects are intercept terms (i.e. the covariance matrix of $y$ is diagonal with entries $\theta\subscript{i}$) and no starting values are provided, the function <code class="highlighter-rouge">mkLmerDevfun</code> continues by computing starting values for $\theta$ as $\sqrt{v / v\subscript{e}}$, where $v$ is a vector with as many entries as there are random terms, containing in each entry the sample variance of $(\bar{y}\subscript{\cdot 1},\ldots,\bar{y}\subscript{\cdot 1}, \bar{y}\subscript{\cdot 2},\ldots,\bar{y}\subscript{\cdot 2}, \ldots)^T$, and $v\subscript{e} = \mathrm{Var}(y) - \sum v\subscript{i}$ (in usual notation $\bar{y}\subscript{\cdot 1}$ denotes the average of the sample values in $y$ belonging to the first level of the random effect). That is, in more intuitive terms the starting value for $\theta\subscript{i}$ is the standard deviation due to the $i$th random effect scaled by the residual standard deviation.</p>

<p>If not all random effects are intercept terms, then the initial values for $\theta$ are 0 off-diagonal and 1 on, as defined via the function <code class="highlighter-rouge">mkReTrms</code> called from the function <code class="highlighter-rouge">lFormula</code> prior to the call of <code class="highlighter-rouge">mkLmerDevfun</code>.</p>

<p>Finally, <code class="highlighter-rouge">devfun</code> is returned, which should also pass the <code class="highlighter-rouge">rho</code> environment implicitly.</p>

<h3 id="lmer_deviance"><code class="highlighter-rouge">lmer_Deviance</code></h3>

<p>This function is defined as <code class="highlighter-rouge">SEXP lmer_Deviance(SEXP pptr_, SEXP rptr_, SEXP theta_)</code> in <code class="highlighter-rouge">external.cpp</code>.
Using the <code class="highlighter-rouge">Rcpp:::Xptr</code> template, it creates two external pointers to instances of the C++ classes <code class="highlighter-rouge">lmerResp</code> and <code class="highlighter-rouge">merPredD</code>, thus exposing all methods of the respective C++ objects to the use from R.</p>

<pre><code class="language-C++">        XPtr&lt;lmerResp&gt;   rpt(rptr_);
        XPtr&lt;merPredD&gt;   ppt(pptr_);
</code></pre>

<p>The function proceeds by calling another function, <code class="highlighter-rouge">lmer_dev</code>, defined in the same file, which carries out the actual computation of the (profiled) deviance function. The mathematical expression of the profiled deviance is essentially given by the following set of formulas (as I have derived in my project plan here: <a href="http://dauns.math.tulane.edu/~agossman/pdfs/GSoC2015_LMM_project_plan.pdf">http://dauns.math.tulane.edu/~agossman/pdfs/GSoC2015_LMM_project_plan.pdf</a>).</p>

<p><img src="/images/profiled_deviance.png?raw=true" alt="profiled deviance formulas (PNG image)" title="profiled_deviance.png" /></p>

<p>The Cholesky decomposed matrix is part of a linear system, predicting the random terms $u$ and the coefficient vector $\beta$.</p>

<p>These math formulas are evaluated in <code class="highlighter-rouge">lmer_dev</code> via the following steps:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">ppt-&gt;setTheta(theta)</code> - Update the parameter vector $\theta$ and the covariance factor $\Lambda\subscript{\theta}$.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ppt-&gt;updateXwts(rpt-&gt;sqrtXwt())</code> - Update the matrix $W$ of $X$ weights. $W$ is not shown above for simplicity, but in fact there is a factor $W^{1/2}$ in front of every $X$ or $Z$ in the above formulas.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">rpt-&gt;updateMu(ppt-&gt;linPred(0.))</code> - Update the (conditional) mean response, the weighted residuals vector, and its sum of squares, based on <code class="highlighter-rouge">d_beta0</code> and <code class="highlighter-rouge">d_u0</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ppt-&gt;updateRes(rpt-&gt;wtres())</code> - Does these auxiliary calculations:</p>
  </li>
</ul>

<pre><code class="language-C++">d_Vtr           = d_V.adjoint() * wtres;
d_Utr           = d_LamtUt * wtres;
</code></pre>

<p>(I donâ€™t really understand the purpose of it at the moment).</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">ppt-&gt;solve()</code> - Performs the above Cholesky decomposition in multiple steps via <code class="highlighter-rouge">CHOLMOD</code> sparse Cholesky methods (possibly also estimates $u$ and maybe some other parameters, but I am not sure).</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">rpt-&gt;updateMu(ppt-&gt;linPred(1.))</code> - Update the (conditional) mean response, the weighted residuals vector, and its sum of squares, based on <code class="highlighter-rouge">d_beta0 + d_delb</code> and <code class="highlighter-rouge">d_u0 + d_delu</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">val=rpt-&gt;Laplace(ppt-&gt;ldL2(), ppt-&gt;ldRX2(), ppt-&gt;sqrL(1.))</code> - Evaluate the profiled deviance based on the previously computed variables (or the profiled REML criterion, which is defined similarly, if the REML flag is set).</p>
  </li>
  <li>
    <p>Return <code class="highlighter-rouge">val</code>.</p>
  </li>
</ul>

<p>It seems that the implementation in the package <a href="https://github.com/lme4/lme4pureR"><code class="highlighter-rouge">lme4pureR</code></a> performs all the same calculations, but is written in a much better readable R code (much fewer lines of code, without external pointers to C++ objects and no C++/C used at all, without passing different R environments from function to function, etc.). I will look at it in detail as soon as I finish dissecting <code class="highlighter-rouge">lme4</code>â€™s <code class="highlighter-rouge">lmer</code>.</p>

  </div>

  <div class="date">
    Written on May 15, 2015
  </div>

  <div class="date">
    Tags:
		
		<a href="/tag/lme4">#lme4</a>
		
  </div>

  
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'agisga';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:alexej.go@gmail.com"><i class="svg-icon email"></i></a>
<a href="https://www.facebook.com/alexej.yexela"><i class="svg-icon facebook"></i></a>

<a href="https://github.com/agisga"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/alexejgossmann"><i class="svg-icon linkedin"></i></a>

<a href="/feed.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/agisga"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-94080131-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/Dissect_lmer_part2/',
		  'title': 'Dissecting lme4\'s lmer function. Part 2.'
		});
	</script>
	<!-- End Google Analytics -->


  </body>
</html>
